const _maxBy = require('lodash.maxby');

/**
 * A function that returns a list of all submissions to be formatted.
 * @param {Object} conn knex client connection object
 * @returns {Promise} returns a promise that resolves to an array of submissions
 */
const getSubmissionsWithPoints = (conn) => {
  return conn('Points AS P')
    .join('Submissions AS S', 'S.ID', 'P.SubmissionID')
    .join('Children AS C', 'C.ID', 'S.ChildID')
    .join('Members AS M', 'S.ID', 'M.SubmissionID')
    .join('Teams AS T', 'T.ID', 'M.TeamID')
    .select([
      'P.WritingPoints',
      'P.DrawingPoints',
      'C.ID AS ChildID',
      'P.ID AS Vote',
      'M.ID AS MemberID',
      'M.TeamID',
      'T.SquadID',
      'S.ID',
    ]);
};

/**
 * Formats an array of submission objects into a hash table.
 * @param {Array} submissions an array of submissions generated by getSubmissionsWithPoints()
 * @returns {Object} returns an object of formatted point sums for a squad
 */
const formatPointSums = (submissions) => {
  // initialize response
  const res = {};
  // Iterate over each submission
  submissions.forEach((page) => {
    // Keep track of votes that have already been counted with a set
    const votes = new Set();
    // If an object has not been generated for the submission id yet (page.ID), then create one
    if (!res[page.ID]) {
      // Read all values from the page object and initialize points to 0
      res[page.ID] = {
        MemberID: page.MemberID,
        SquadID: page.SquadID,
        TeamID: page.TeamID,
        SubmissionID: page.ID,
        ChildID: page.ChildID,
        WritingPoints: 0,
        DrawingPoints: 0,
      };
    }
    // If it's the first time seeing the Votes entry with ID page.Vote
    if (!votes.has(page.Vote)) {
      // Add the vote to our votes set to signal we've already counted it
      votes.add(page.Vote);
      // Increment the points values in the response object
      res[page.ID].WritingPoints += page.WritingPoints;
      res[page.ID].DrawingPoints += page.DrawingPoints;
    }
  });
  return res;
};

/**
 * Sorts the submissions generated by formatPointSums() into a nested object with the structure:\
 * res: { [SquadID]: { [TeamID]: [sub, sub], [TeamID]: [sub, sub] } }
 * @param {Object} submissions pass in the Object.values() of the submission data returned from formatPointSums()
 * @returns {Object} returns submissions sorted into an object by squad id then by team id
 */
const sortBySquad = (submissions) => {
  // Initialize a response object
  const teams = {};
  // Iterate over each submission
  submissions.forEach((sub) => {
    // Initialize a reponse value the first time you see each squad ID
    if (!teams[sub.SquadID]) teams[sub.SquadID] = {};
    // Initialize an array in the teams[squadid] object with the key TeamID
    if (!teams[sub.SquadID][sub.TeamID]) teams[sub.SquadID][sub.TeamID] = [];
    // Push each submission to the relevant [squad][team] array
    teams[sub.SquadID][sub.TeamID].push(sub);
  });
  return teams;
};

/**
 * This function iterates over the submissions sorted by squad/team (returned by sortBySquad()) and then pairs
 * the highest- and lowest-rated writing and drawing submissions from each squad off to be matched up against
 * each other in the Faceoffs table
 * @param {Object} squads object returned by sortBySquad()
 * @returns {Array} returns an array of objects to be inserted into the Faceoffs table
 */
const groupOnPoints = (squads) => {
  // Initialize the response array
  const matchups = [];
  // Iterate over the squads by their key, SquadID
  for (let SquadID in squads) {
    // Initialize arrays to keep track of the highest/lowest scoring writing/drawing subs
    let maxWritingSubs = [];
    let minWritingSubs = [];
    let maxDrawingSubs = [];
    let minDrawingSubs = [];
    // Iterate over the teams in each squad on key TeamID
    for (let TeamID in squads[SquadID]) {
      // Generate writing matchups (the function returns an array which we're destructuring the index values out of)
      const [wMaxI, wMinI] = rankSubs(squads[SquadID][TeamID], 'Writing');
      // Add this matchups to their respective min/max arrays
      maxWritingSubs.push(squads[SquadID][TeamID][wMaxI]);
      minWritingSubs.push(squads[SquadID][TeamID][wMinI]);

      // generate drawing matchups (again, using array destructuring to get index values of mix/max point submissions)
      const [dMaxI, dMinI] = rankSubs(squads[SquadID][TeamID], 'Drawing');
      // Add those matchups to their respective arrays
      maxDrawingSubs.push(squads[SquadID][TeamID][dMaxI]);
      minDrawingSubs.push(squads[SquadID][TeamID][dMinI]);
    }
    // Format each matchup we just generated and push them to our top-level response array, matchups
    matchups.push(
      formatMatchup(maxWritingSubs, 'WRITING'),
      formatMatchup(minWritingSubs, 'WRITING'),
      formatMatchup(maxDrawingSubs, 'DRAWING'),
      formatMatchup(minDrawingSubs, 'DRAWING')
    );
  }
  return matchups;
};

/**
 * This function takes an array of two submissions (both from the same team) and calculates
 * which submission has the higher points for a given field, eitehr Writing or Drawing. It then
 * returns the indices in an array, [higherindex, lowerindex] to be destructured as such.
 * @param {Array} teamRef a reference to an array of submissions in a team object,\
 * { [SquadID]: { [TeamID]: [ sub1, sub2 ], [TeamID]: [ sub1, sub2 ] } }
 * @param {string} type a string representing which point value to generate rankings
 *                      based off of, either 'Writing' or 'Drawing
 * @returns {Array} an array where\
 *                  array[0] = the index of the sub with higher points
 *                  array[1] = the index of the sub with lower points
 */
const rankSubs = (teamRef, type) => {
  // Find the index of the submission with the most points of a given Type (Writing or Drawing)
  const maxSubIndex = teamRef.indexOf(_maxBy(teamRef, `${type}Points`));
  // Since there are only two elements in the array, if the maxIndex is one, the minIndex must be 0, and vice versa
  // const minSubIndex = maxSubIndex ? 0 : 1; // This can be simplified to arithmetic, not logic!
  const minSubIndex = 1 - maxSubIndex; // Simple arithmetic operation to replace the above ternary
  // Returns the idneices in an array for simple destructuring
  return [maxSubIndex, minSubIndex];
};

/**
 * This function takes an array of two submissions and a Type and formats them into a Faceoffs
 * object that has the correct fields and values for the database table. It uses the Type as a
 * flag to decide whether to add the writing or drawing points for the Faceoff's points value.
 * @param {Array} subs an array of two submissions to be matched up together
 * @param {string} Type the submission type to count points for, 'WRITING' or 'DRAWING'
 */
const formatMatchup = (subs, Type) => ({
  Points:
    subs[0][Type === 'WRITING' ? 'WritingPoints' : 'DrawingPoints'] +
    subs[1][Type === 'WRITING' ? 'WritingPoints' : 'DrawingPoints'],
  Type,
  SubmissionID1: subs[0].SubmissionID,
  SubmissionID2: subs[1].SubmissionID,
  SquadID: subs[0].SquadID,
});

module.exports = {
  getSubmissionsWithPoints,
  formatPointSums,
  sortBySquad,
  groupOnPoints,
};
